<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Numpy-in-Gumtree: numpy.nparray.ndarray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Numpy-in-Gumtree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>numpy</b></li><li class="navelem"><a class="el" href="namespacenumpy_1_1nparray.html">nparray</a></li><li class="navelem"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html">ndarray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classnumpy_1_1nparray_1_1ndarray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">numpy.nparray.ndarray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for numpy.nparray.ndarray:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnumpy_1_1nparray_1_1ndarray.png" usemap="#numpy.nparray.ndarray_map" alt=""/>
  <map id="numpy.nparray.ndarray_map" name="numpy.nparray.ndarray_map">
<area href="classnumpy_1_1npmatrix_1_1matrix.html" alt="numpy.npmatrix.matrix" shape="rect" coords="0,56,147,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae26fcc05dbae13736ad796221cf17b20"><td class="memItemLeft" align="right" valign="top"><a id="ae26fcc05dbae13736ad796221cf17b20"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, shape=None, dtype=float, buffer=None, offset=None, strides=None, order=None)</td></tr>
<tr class="separator:ae26fcc05dbae13736ad796221cf17b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294904dc02cdb23ffe1a274741fbc8c9"><td class="memItemLeft" align="right" valign="top"><a id="a294904dc02cdb23ffe1a274741fbc8c9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__getattr__</b> (self, name)</td></tr>
<tr class="separator:a294904dc02cdb23ffe1a274741fbc8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f52299e193186aaf7b05cb927f606"><td class="memItemLeft" align="right" valign="top"><a id="a746f52299e193186aaf7b05cb927f606"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__getitem__</b> (self, index)</td></tr>
<tr class="separator:a746f52299e193186aaf7b05cb927f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340adfcec2894bfd6363031d45485dd6"><td class="memItemLeft" align="right" valign="top"><a id="a340adfcec2894bfd6363031d45485dd6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__setitem__</b> (self, index, value)</td></tr>
<tr class="separator:a340adfcec2894bfd6363031d45485dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6719d9f94ccda1e87ec8a9936b9c46ec"><td class="memItemLeft" align="right" valign="top"><a id="a6719d9f94ccda1e87ec8a9936b9c46ec"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__str__</b> (self, indent='')</td></tr>
<tr class="separator:a6719d9f94ccda1e87ec8a9936b9c46ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace41f0e1c75842af93b8349f4d32887d"><td class="memItemLeft" align="right" valign="top"><a id="ace41f0e1c75842af93b8349f4d32887d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__repr__</b> (self, indent='', skip=True, precision=None)</td></tr>
<tr class="separator:ace41f0e1c75842af93b8349f4d32887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5707b87837372bce3cccccd5b4685"><td class="memItemLeft" align="right" valign="top"><a id="ad5f5707b87837372bce3cccccd5b4685"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__len__</b> (self)</td></tr>
<tr class="separator:ad5f5707b87837372bce3cccccd5b4685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9f4223c20fcd0b1006f13557577e8d"><td class="memItemLeft" align="right" valign="top"><a id="a0b9f4223c20fcd0b1006f13557577e8d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__iter__</b> (self)</td></tr>
<tr class="separator:a0b9f4223c20fcd0b1006f13557577e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea402be051038c8eaaedbb83d996964"><td class="memItemLeft" align="right" valign="top"><a id="afea402be051038c8eaaedbb83d996964"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__copy__</b> (self)</td></tr>
<tr class="separator:afea402be051038c8eaaedbb83d996964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebe38a322c4250cc01d454bed9b516a"><td class="memItemLeft" align="right" valign="top"><a id="a4ebe38a322c4250cc01d454bed9b516a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__deepcopy__</b> (self)</td></tr>
<tr class="separator:a4ebe38a322c4250cc01d454bed9b516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548cafb8c91455395acfa8eea279141c"><td class="memItemLeft" align="right" valign="top"><a id="a548cafb8c91455395acfa8eea279141c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__eq__</b> (self, obj)</td></tr>
<tr class="separator:a548cafb8c91455395acfa8eea279141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34d672f5c693759d5af69894491b900"><td class="memItemLeft" align="right" valign="top"><a id="ab34d672f5c693759d5af69894491b900"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ne__</b> (self, obj)</td></tr>
<tr class="separator:ab34d672f5c693759d5af69894491b900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef00e7fc76bd334fd4f48958428d7c76"><td class="memItemLeft" align="right" valign="top"><a id="aef00e7fc76bd334fd4f48958428d7c76"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__lt__</b> (self, obj)</td></tr>
<tr class="separator:aef00e7fc76bd334fd4f48958428d7c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def7dd57c798edfac3ced1e3d6cf796"><td class="memItemLeft" align="right" valign="top"><a id="a5def7dd57c798edfac3ced1e3d6cf796"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__le__</b> (self, obj)</td></tr>
<tr class="separator:a5def7dd57c798edfac3ced1e3d6cf796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bcd18934f8712b805f8a0387ece2f3"><td class="memItemLeft" align="right" valign="top"><a id="a78bcd18934f8712b805f8a0387ece2f3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__gt__</b> (self, obj)</td></tr>
<tr class="separator:a78bcd18934f8712b805f8a0387ece2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381483604ab9d978258a0053c7b07fb4"><td class="memItemLeft" align="right" valign="top"><a id="a381483604ab9d978258a0053c7b07fb4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ge__</b> (self, obj)</td></tr>
<tr class="separator:a381483604ab9d978258a0053c7b07fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8909b11189e679b9703c7434b92d9c"><td class="memItemLeft" align="right" valign="top"><a id="a3a8909b11189e679b9703c7434b92d9c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__not__</b> (self)</td></tr>
<tr class="separator:a3a8909b11189e679b9703c7434b92d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe60de4aecc9aa933b5826fa5f2ca14c"><td class="memItemLeft" align="right" valign="top"><a id="afe60de4aecc9aa933b5826fa5f2ca14c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__bool__</b> (self)</td></tr>
<tr class="separator:afe60de4aecc9aa933b5826fa5f2ca14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be24fd887961f3b02d70c5f6e23f550"><td class="memItemLeft" align="right" valign="top"><a id="a6be24fd887961f3b02d70c5f6e23f550"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__or__</b> (self, obj)</td></tr>
<tr class="separator:a6be24fd887961f3b02d70c5f6e23f550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6865d76153b32c2f9fa970592ffe9d11"><td class="memItemLeft" align="right" valign="top"><a id="a6865d76153b32c2f9fa970592ffe9d11"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ior__</b> (self, obj)</td></tr>
<tr class="separator:a6865d76153b32c2f9fa970592ffe9d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb07da6499bbb6d325bec8530334a04"><td class="memItemLeft" align="right" valign="top"><a id="a3cb07da6499bbb6d325bec8530334a04"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__xor__</b> (self, obj)</td></tr>
<tr class="separator:a3cb07da6499bbb6d325bec8530334a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9fb6ea63dfbf034e8deed5c7e8bd7e"><td class="memItemLeft" align="right" valign="top"><a id="abe9fb6ea63dfbf034e8deed5c7e8bd7e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ixor__</b> (self, obj)</td></tr>
<tr class="separator:abe9fb6ea63dfbf034e8deed5c7e8bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253e0cc9b304a43dd9a7c7ede48f9a0b"><td class="memItemLeft" align="right" valign="top"><a id="a253e0cc9b304a43dd9a7c7ede48f9a0b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__and__</b> (self, obj)</td></tr>
<tr class="separator:a253e0cc9b304a43dd9a7c7ede48f9a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4ec6698f544896fafe1d453f9418b4"><td class="memItemLeft" align="right" valign="top"><a id="a6a4ec6698f544896fafe1d453f9418b4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__iand__</b> (self, obj)</td></tr>
<tr class="separator:a6a4ec6698f544896fafe1d453f9418b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af625921a2828f4fcd5dbdfac28b1fea9"><td class="memItemLeft" align="right" valign="top"><a id="af625921a2828f4fcd5dbdfac28b1fea9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__add__</b> (self, obj)</td></tr>
<tr class="separator:af625921a2828f4fcd5dbdfac28b1fea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdc82a1b5093191d59f19b4b1d0c178"><td class="memItemLeft" align="right" valign="top"><a id="acfdc82a1b5093191d59f19b4b1d0c178"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__iadd__</b> (self, obj)</td></tr>
<tr class="separator:acfdc82a1b5093191d59f19b4b1d0c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b1d54831896ed110e3e0b51c07d55b"><td class="memItemLeft" align="right" valign="top"><a id="af9b1d54831896ed110e3e0b51c07d55b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__radd__</b> (self, obj)</td></tr>
<tr class="separator:af9b1d54831896ed110e3e0b51c07d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17beb16d2805b8b7db7e513558e4e09b"><td class="memItemLeft" align="right" valign="top"><a id="a17beb16d2805b8b7db7e513558e4e09b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__div__</b> (self, obj)</td></tr>
<tr class="separator:a17beb16d2805b8b7db7e513558e4e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def86e60945673009cfa7e550806575"><td class="memItemLeft" align="right" valign="top"><a id="a9def86e60945673009cfa7e550806575"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__floordiv__</b> (self, obj)</td></tr>
<tr class="separator:a9def86e60945673009cfa7e550806575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c650bd23371abe7823a5cf428bd0b1a"><td class="memItemLeft" align="right" valign="top"><a id="a6c650bd23371abe7823a5cf428bd0b1a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__truediv__</b> (self, obj)</td></tr>
<tr class="separator:a6c650bd23371abe7823a5cf428bd0b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e93485b3e2ae44d94c77aa0f286670"><td class="memItemLeft" align="right" valign="top"><a id="af2e93485b3e2ae44d94c77aa0f286670"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__mod__</b> (self, obj)</td></tr>
<tr class="separator:af2e93485b3e2ae44d94c77aa0f286670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861c85661dce9bba65d4bbbf141f7dae"><td class="memItemLeft" align="right" valign="top"><a id="a861c85661dce9bba65d4bbbf141f7dae"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__rmod__</b> (self, obj)</td></tr>
<tr class="separator:a861c85661dce9bba65d4bbbf141f7dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5fd4113e52a471803b6bb1c4f599a"><td class="memItemLeft" align="right" valign="top"><a id="a2da5fd4113e52a471803b6bb1c4f599a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__divmod__</b> (self, obj)</td></tr>
<tr class="separator:a2da5fd4113e52a471803b6bb1c4f599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3cf2edc8cae0a06efa712c47e10d29"><td class="memItemLeft" align="right" valign="top"><a id="aae3cf2edc8cae0a06efa712c47e10d29"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__idiv__</b> (self, obj)</td></tr>
<tr class="separator:aae3cf2edc8cae0a06efa712c47e10d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc162e8d9ddca3f29d51a5f7dde17d6"><td class="memItemLeft" align="right" valign="top"><a id="adbc162e8d9ddca3f29d51a5f7dde17d6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__imod__</b> (self, obj)</td></tr>
<tr class="separator:adbc162e8d9ddca3f29d51a5f7dde17d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6efd4d5da411048ac8d5d658d44b45"><td class="memItemLeft" align="right" valign="top"><a id="a0e6efd4d5da411048ac8d5d658d44b45"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__itruediv__</b> (self, obj)</td></tr>
<tr class="separator:a0e6efd4d5da411048ac8d5d658d44b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6730c28147947da006cdc05434edf367"><td class="memItemLeft" align="right" valign="top"><a id="a6730c28147947da006cdc05434edf367"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ifloordiv__</b> (self, obj)</td></tr>
<tr class="separator:a6730c28147947da006cdc05434edf367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308ca2e8ac16f9a9a6f8b409bf72b9c8"><td class="memItemLeft" align="right" valign="top"><a id="a308ca2e8ac16f9a9a6f8b409bf72b9c8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__rdiv__</b> (self, obj)</td></tr>
<tr class="separator:a308ca2e8ac16f9a9a6f8b409bf72b9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5bcd0462592c82e0782ed0e632d4bf"><td class="memItemLeft" align="right" valign="top"><a id="a8f5bcd0462592c82e0782ed0e632d4bf"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__mul__</b> (self, obj)</td></tr>
<tr class="separator:a8f5bcd0462592c82e0782ed0e632d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01acdfb11cbb8826028b7b4ac2fb24dc"><td class="memItemLeft" align="right" valign="top"><a id="a01acdfb11cbb8826028b7b4ac2fb24dc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__imul__</b> (self, obj)</td></tr>
<tr class="separator:a01acdfb11cbb8826028b7b4ac2fb24dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb971258a76c03b190178769814907c6"><td class="memItemLeft" align="right" valign="top"><a id="abb971258a76c03b190178769814907c6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__rmul__</b> (self, obj)</td></tr>
<tr class="separator:abb971258a76c03b190178769814907c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf688a12734739e4136e44fda8910482"><td class="memItemLeft" align="right" valign="top"><a id="aaf688a12734739e4136e44fda8910482"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__neg__</b> (self)</td></tr>
<tr class="separator:aaf688a12734739e4136e44fda8910482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6589ec8d054ff61a0ec4b2039b67271"><td class="memItemLeft" align="right" valign="top"><a id="aa6589ec8d054ff61a0ec4b2039b67271"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__pos__</b> (self)</td></tr>
<tr class="separator:aa6589ec8d054ff61a0ec4b2039b67271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1c0ac9e62e4888913eec5e065036e2"><td class="memItemLeft" align="right" valign="top"><a id="a2d1c0ac9e62e4888913eec5e065036e2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__sub__</b> (self, obj)</td></tr>
<tr class="separator:a2d1c0ac9e62e4888913eec5e065036e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cc54b47383b262d48e0cc207135e87"><td class="memItemLeft" align="right" valign="top"><a id="a12cc54b47383b262d48e0cc207135e87"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__isub__</b> (self, obj)</td></tr>
<tr class="separator:a12cc54b47383b262d48e0cc207135e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1bbbbbf9f52979106efa492d49abdf"><td class="memItemLeft" align="right" valign="top"><a id="a3b1bbbbbf9f52979106efa492d49abdf"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__rsub__</b> (self, obj)</td></tr>
<tr class="separator:a3b1bbbbbf9f52979106efa492d49abdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526cf78cde96e5eb2dbbbd63002a21e"><td class="memItemLeft" align="right" valign="top"><a id="ad526cf78cde96e5eb2dbbbd63002a21e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__invert__</b> (self)</td></tr>
<tr class="separator:ad526cf78cde96e5eb2dbbbd63002a21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb5a2cc76131a9535cd5a6d5300a94"><td class="memItemLeft" align="right" valign="top"><a id="ac2eb5a2cc76131a9535cd5a6d5300a94"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__abs__</b> (self)</td></tr>
<tr class="separator:ac2eb5a2cc76131a9535cd5a6d5300a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53108598dee6c6fa015d5878a0de1b8"><td class="memItemLeft" align="right" valign="top"><a id="ab53108598dee6c6fa015d5878a0de1b8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__pow__</b> (self, obj)</td></tr>
<tr class="separator:ab53108598dee6c6fa015d5878a0de1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c5a6650a42b0fc5106ba558db89a2"><td class="memItemLeft" align="right" valign="top"><a id="ad74c5a6650a42b0fc5106ba558db89a2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__ipow__</b> (self, obj)</td></tr>
<tr class="separator:ad74c5a6650a42b0fc5106ba558db89a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410787e8ee4f748dc652706906c4ea3"><td class="memItemLeft" align="right" valign="top"><a id="a2410787e8ee4f748dc652706906c4ea3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__rpow__</b> (self, obj)</td></tr>
<tr class="separator:a2410787e8ee4f748dc652706906c4ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520738097f12325c77dc7409e396941"><td class="memItemLeft" align="right" valign="top"><a id="a9520738097f12325c77dc7409e396941"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__int__</b> (self)</td></tr>
<tr class="separator:a9520738097f12325c77dc7409e396941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522062e72cfdd044c90fbd5ab583f5e5"><td class="memItemLeft" align="right" valign="top"><a id="a522062e72cfdd044c90fbd5ab583f5e5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__float__</b> (self)</td></tr>
<tr class="separator:a522062e72cfdd044c90fbd5ab583f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ca2ab945bdd9b4c9bc0fd88dab9523"><td class="memItemLeft" align="right" valign="top"><a id="ae9ca2ab945bdd9b4c9bc0fd88dab9523"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__long__</b> (self)</td></tr>
<tr class="separator:ae9ca2ab945bdd9b4c9bc0fd88dab9523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3ac87ef01a7e44b48f9958a877a79"><td class="memItemLeft" align="right" valign="top"><a id="ad2c3ac87ef01a7e44b48f9958a877a79"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__matmul__</b> (self, value)</td></tr>
<tr class="separator:ad2c3ac87ef01a7e44b48f9958a877a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2412e5536ada63f4e15ea33fa6160f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a2c2412e5536ada63f4e15ea33fa6160f">item</a> (self, *args)</td></tr>
<tr class="separator:a2c2412e5536ada63f4e15ea33fa6160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5a7a1d0c87f0c1412790189d198cbb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#aea5a7a1d0c87f0c1412790189d198cbb">itemset</a> (self, *args)</td></tr>
<tr class="separator:aea5a7a1d0c87f0c1412790189d198cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc80e38b1c33dcf79976085be5a1acbf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#adc80e38b1c33dcf79976085be5a1acbf">copy</a> (self, subok=True)</td></tr>
<tr class="separator:adc80e38b1c33dcf79976085be5a1acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ae58d6c7caa72ff92e07c077cb6ccb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a63ae58d6c7caa72ff92e07c077cb6ccb">dump</a> (self, file)</td></tr>
<tr class="separator:a63ae58d6c7caa72ff92e07c077cb6ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c4369edf088a69c66e80c9190ad85a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a98c4369edf088a69c66e80c9190ad85a">dumps</a> (self)</td></tr>
<tr class="separator:a98c4369edf088a69c66e80c9190ad85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac779e447ac5e590f23db3eaa07019484"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ac779e447ac5e590f23db3eaa07019484">all</a> (self, axis=None, out=None, keepdims=False)</td></tr>
<tr class="separator:ac779e447ac5e590f23db3eaa07019484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d99daab76f0f266e985b632f9325e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ad4d99daab76f0f266e985b632f9325e1">any</a> (self, axis=None, out=None, keepdims=False)</td></tr>
<tr class="separator:ad4d99daab76f0f266e985b632f9325e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10602777d2081f01c8013dba3494ae3e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a10602777d2081f01c8013dba3494ae3e">max</a> (self, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a10602777d2081f01c8013dba3494ae3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2d7c2c937a06713f3cf233f4c2626"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a76a2d7c2c937a06713f3cf233f4c2626">min</a> (self, axis=None, out=None, keepdims=None, initial=None, where=None)</td></tr>
<tr class="separator:a76a2d7c2c937a06713f3cf233f4c2626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b6caaa3f08a49fff4d76c71713d29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a5d1b6caaa3f08a49fff4d76c71713d29">mean</a> (self, axis=None, dtype=None, out=None, keepdims=False)</td></tr>
<tr class="separator:a5d1b6caaa3f08a49fff4d76c71713d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89458857ad4a562f64aff3b38e4c82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a1f89458857ad4a562f64aff3b38e4c82">argmax</a> (self, axis=None, out=None)</td></tr>
<tr class="separator:a1f89458857ad4a562f64aff3b38e4c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4c6a54a756806eaefef161df76e3ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a7a4c6a54a756806eaefef161df76e3ac">argmin</a> (self, axis=None, out=None)</td></tr>
<tr class="separator:a7a4c6a54a756806eaefef161df76e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8957f8dfc403736bfcba13aba437db7e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a8957f8dfc403736bfcba13aba437db7e">cumprod</a> (self, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a8957f8dfc403736bfcba13aba437db7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aed0d0ea9c4183c57277aad20623571"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a1aed0d0ea9c4183c57277aad20623571">cumsum</a> (self, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a1aed0d0ea9c4183c57277aad20623571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f51491ed947496d2b7e2efbf99a76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a267f51491ed947496d2b7e2efbf99a76">dot</a> (self, b, out=None)</td></tr>
<tr class="separator:a267f51491ed947496d2b7e2efbf99a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c153eb3dbb44fa7220ef566e08b622"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a67c153eb3dbb44fa7220ef566e08b622">nonzero</a> (self)</td></tr>
<tr class="separator:a67c153eb3dbb44fa7220ef566e08b622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9921ab0d5328000e510065627f4768"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a7a9921ab0d5328000e510065627f4768">sum</a> (self, axis=None, dtype=None, out=None, keepdims=None, initial=0, where=None)</td></tr>
<tr class="separator:a7a9921ab0d5328000e510065627f4768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46963e32fc541e14bdb37b9a557cfe5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a46963e32fc541e14bdb37b9a557cfe5a">prod</a> (self, axis=None, dtype=None, out=None, keepdims=None, initial=1, where=None)</td></tr>
<tr class="separator:a46963e32fc541e14bdb37b9a557cfe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ea8d601f7e3747ee9d6a73877e0580"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a29ea8d601f7e3747ee9d6a73877e0580">ptp</a> (self, axis=None, out=None, keepdims=None)</td></tr>
<tr class="separator:a29ea8d601f7e3747ee9d6a73877e0580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df22bf1f3cffd1b3ab3f9923b9cc508"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a9df22bf1f3cffd1b3ab3f9923b9cc508">round</a> (self, decimals=0, out=None)</td></tr>
<tr class="separator:a9df22bf1f3cffd1b3ab3f9923b9cc508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320d6622923998bb2c1a0ddc25fd390"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a1320d6622923998bb2c1a0ddc25fd390">sort</a> (self, axis=-1, reverse=False)</td></tr>
<tr class="separator:a1320d6622923998bb2c1a0ddc25fd390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d36ed3269a89b2aa72d3bf46de21c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a30d36ed3269a89b2aa72d3bf46de21c1">std</a> (self, axis=None, dtype=None, out=None, ddof=0)</td></tr>
<tr class="separator:a30d36ed3269a89b2aa72d3bf46de21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98d3b9f0c855f2c479293317c89593d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ad98d3b9f0c855f2c479293317c89593d">var</a> (self, axis=None, dtype=None, out=None, ddof=0)</td></tr>
<tr class="separator:ad98d3b9f0c855f2c479293317c89593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969c6cb8dcb870f01467c9e8f45233b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a969c6cb8dcb870f01467c9e8f45233b7">astype</a> (self, dtype, order='K', casting='unsafe', subok=True, <a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#adc80e38b1c33dcf79976085be5a1acbf">copy</a>=True)</td></tr>
<tr class="separator:a969c6cb8dcb870f01467c9e8f45233b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263850a9c6f87e0b97cc4939909add63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a263850a9c6f87e0b97cc4939909add63">flatten</a> (self, order='C')</td></tr>
<tr class="separator:a263850a9c6f87e0b97cc4939909add63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0b8c63f9c89c45c3fe5881ac9655c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#af6b0b8c63f9c89c45c3fe5881ac9655c">ravel</a> (self)</td></tr>
<tr class="separator:af6b0b8c63f9c89c45c3fe5881ac9655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d029bcaee37d7f6d9aaf2938b0ff9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a699d029bcaee37d7f6d9aaf2938b0ff9">repeat</a> (self, repeats, axis=None)</td></tr>
<tr class="separator:a699d029bcaee37d7f6d9aaf2938b0ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c89171b8915bb05a88fb27521e95b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#aa80c89171b8915bb05a88fb27521e95b">clip</a> (self, <a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a76a2d7c2c937a06713f3cf233f4c2626">min</a>=None, <a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a10602777d2081f01c8013dba3494ae3e">max</a>=None, out=None)</td></tr>
<tr class="separator:aa80c89171b8915bb05a88fb27521e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac324583ee08905f693164ad5003aeb2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ac324583ee08905f693164ad5003aeb2c">put</a> (self, indices, values, mode='raise')</td></tr>
<tr class="separator:ac324583ee08905f693164ad5003aeb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd9026b7cdaa489ab3ac701b7d1162"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a95dd9026b7cdaa489ab3ac701b7d1162">moveaxis</a> (self, source, destination)</td></tr>
<tr class="separator:a95dd9026b7cdaa489ab3ac701b7d1162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acfeed7c23a8b1e3964e300726bb25b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a1acfeed7c23a8b1e3964e300726bb25b">swapaxes</a> (self, axis1, axis2)</td></tr>
<tr class="separator:a1acfeed7c23a8b1e3964e300726bb25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2e7487ccfe87f2e8dff9e79902e27a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ade2e7487ccfe87f2e8dff9e79902e27a">transpose</a> (self, axes=None)</td></tr>
<tr class="separator:ade2e7487ccfe87f2e8dff9e79902e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ae11a06791802ec2ca3a5059f2d275"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a73ae11a06791802ec2ca3a5059f2d275">compress</a> (self, condition, axis=None, out=None)</td></tr>
<tr class="separator:a73ae11a06791802ec2ca3a5059f2d275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90411a625588831b05a3c485374be1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a8f90411a625588831b05a3c485374be1">fill</a> (self, value)</td></tr>
<tr class="separator:a8f90411a625588831b05a3c485374be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ec6700a24a40b5e19d5c8aa3903135"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a58ec6700a24a40b5e19d5c8aa3903135">reshape</a> (self, *shape)</td></tr>
<tr class="separator:a58ec6700a24a40b5e19d5c8aa3903135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aee52b0a73c9dccce97f82b011d3cd8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a5aee52b0a73c9dccce97f82b011d3cd8">resize</a> (self, *new_size)</td></tr>
<tr class="separator:a5aee52b0a73c9dccce97f82b011d3cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6ff18f4e3ea414cdab5d76bf47448c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#aff6ff18f4e3ea414cdab5d76bf47448c">squeeze</a> (self, axis=None)</td></tr>
<tr class="separator:aff6ff18f4e3ea414cdab5d76bf47448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec315367ee238644b4c012b85a0694de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#aec315367ee238644b4c012b85a0694de">searchsorted</a> (self, v, side='left', sorter=None)</td></tr>
<tr class="separator:aec315367ee238644b4c012b85a0694de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fa63a73d7b830c0c544f83a41b569c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a97fa63a73d7b830c0c544f83a41b569c">diagonal</a> (self, offset=0, axis1=0, axis2=1)</td></tr>
<tr class="separator:a97fa63a73d7b830c0c544f83a41b569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2350c9a650d043a40b2e170afe59652"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#ac2350c9a650d043a40b2e170afe59652">trace</a> (self, offset=0, axis1=0, axis2=1, dtype=None, out=None)</td></tr>
<tr class="separator:ac2350c9a650d043a40b2e170afe59652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd7f02740a19bc157ea2408e7f7a6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a10dd7f02740a19bc157ea2408e7f7a6e">tril</a> (self, k=0)</td></tr>
<tr class="separator:a10dd7f02740a19bc157ea2408e7f7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae42fa1b841700c3f1089b64f0804468"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#aae42fa1b841700c3f1089b64f0804468">triu</a> (self, k=0)</td></tr>
<tr class="separator:aae42fa1b841700c3f1089b64f0804468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaed6e6e798a20864538ec2f8d3dcc8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#abdaed6e6e798a20864538ec2f8d3dcc8">take</a> (self, indices, axis=None, out=None, mode=None)</td></tr>
<tr class="separator:abdaed6e6e798a20864538ec2f8d3dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1459af74bd1e5ff62773a95e5dae02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1nparray_1_1ndarray.html#a1b1459af74bd1e5ff62773a95e5dae02">tolist</a> (self)</td></tr>
<tr class="separator:a1b1459af74bd1e5ff62773a95e5dae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac241cb006a1c285da3b6b40648b4e7a9"><td class="memItemLeft" align="right" valign="top"><a id="ac241cb006a1c285da3b6b40648b4e7a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr class="separator:ac241cb006a1c285da3b6b40648b4e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87406d8344a4949a63567c08ca6119e6"><td class="memItemLeft" align="right" valign="top"><a id="a87406d8344a4949a63567c08ca6119e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="separator:a87406d8344a4949a63567c08ca6119e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac779e447ac5e590f23db3eaa07019484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac779e447ac5e590f23db3eaa07019484">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns True if all elements evaluate to True.

    Parameters:
    
        axis : None or int or tuple of ints, optional
            Axis or axes along which a logical AND reduction is performed. 
            The default (axis=None) is to perform a logical AND over all 
            the dimensions of the input array. axis may be negative, in 
            which case it counts from the last to the first axis.

            If this is a tuple of ints, a reduction is performed on multiple 
            axes, instead of a single axis or all the axes as before.

        out : ndarray, optional
            Alternate output array in which to place the result. It must 
            have the same shape as the expected output and its type is 
            preserved (e.g., if dtype(out) is float, the result will consist 
            of 0.0's and 1.0's). See ufuncs-output-type for more details.

        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left in 
            the result as dimensions with size one. With this option, the 
            result will broadcast correctly against the input array.

            If the default value is passed, then keepdims will not be passed 
            through to the all method of sub-classes of ndarray, however any 
            non-default value will be. If the sub-class' method does not 
            implement keepdims any exceptions will be raised.

    Returns

        all : ndarray, bool
            A new boolean or array is returned unless out is specified, in 
            which case a reference to out is returned.</pre> 
</div>
</div>
<a id="ad4d99daab76f0f266e985b632f9325e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d99daab76f0f266e985b632f9325e1">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.any </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns True if any of the elements of a evaluate to True.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which a logical OR reduction is performed. 
            The default (axis=None) is to perform a logical OR over all 
            the dimensions of the input array. axis may be negative, in 
            which case it counts from the last to the first axis.

            If this is a tuple of ints, a reduction is performed on 
            multiple axes, instead of a single axis or all the axes as 
            before.

        out : ndarray, optional
            Alternate output array in which to place the result. It must 
            have the same shape as the expected output and its type is 
            preserved (e.g., if it is of type float, then it will remain 
            so, returning 1.0 for True and 0.0 for False, regardless of 
            the type of a). See ufuncs-output-type for more details.

        keep : dimsbool, optional
            If this is set to True, the axes which are reduced are left 
            in the result as dimensions with size one. With this option, 
            the result will broadcast correctly against the input array.

            If the default value is passed, then keepdims will not be 
            passed through to the any method of sub-classes of ndarray, 
            however any non-default value will be. If the sub-class' 
            method does not implement keepdims any exceptions will be 
            raised.

    Returns

        any : bool or ndarray
            A new boolean or ndarray is returned unless out is specified, 
            in which case a reference to out is returned.</pre> 
</div>
</div>
<a id="a1f89458857ad4a562f64aff3b38e4c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f89458857ad4a562f64aff3b38e4c82">&#9670;&nbsp;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.argmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the indices of the maximum values along an axis.

    Parameters
    
        axis : int, optional
            By default, the index is into the flattened array, 
            otherwise along the specified axis.

        out : array, optional
            If provided, the result will be inserted into this array. 
            It should be of the appropriate shape and dtype.

    Returns

        index_arrayndarray of ints
            Array of indices into the array. It has the same shape 
            as a.shape with the dimension along axis removed.</pre> 
</div>
</div>
<a id="a7a4c6a54a756806eaefef161df76e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4c6a54a756806eaefef161df76e3ac">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.argmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the indices of the minimum values along an axis.

    Parameters

        axis : int, optional
            By default, the index is into the flattened array, 
            otherwise along the specified axis.

        out : array, optional
            If provided, the result will be inserted into this array. 
            It should be of the appropriate shape and dtype.

    Returns

        index_array : ndarray of ints
            Array of indices into the array. It has the same shape as 
            a.shape with the dimension along axis removed.</pre> 
</div>
</div>
<a id="a969c6cb8dcb870f01467c9e8f45233b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969c6cb8dcb870f01467c9e8f45233b7">&#9670;&nbsp;</a></span>astype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.astype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>casting</em> = <code>'unsafe'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Copy of the array, cast to a specified type.

    Parameters

        dtype : str or dtype
            Typecode or data-type to which the array is cast.

        order : not supported

        casting : not supported
            
        subok : bool, optional
            If True, then sub-classes will be passed-through (default), 
            otherwise the returned array will be forced to be a base-class 
            array.

        copy : not supported

    Returns

        arr_t : ndarray
            A new array of the same shape as the input array, with dtype, 
            order given by dtype, order.

    Raises

        ComplexWarning
            When casting from complex to float or int. To avoid this, 
            one should use a.real.astype(t).</pre> 
</div>
</div>
<a id="aa80c89171b8915bb05a88fb27521e95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c89171b8915bb05a88fb27521e95b">&#9670;&nbsp;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.clip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Clip (limit) the values in an array.

    Given an interval, values outside the interval are clipped to the 
    interval edges. For example, if an interval of [0, 1] is specified, 
    values smaller than 0 become 0, and values larger than 1 become 1.

    Equivalent to but faster than np.minimum(a_max, np.maximum(a, a_min)).

    No check is performed to ensure a_min &lt; a_max.

    Parameters

        a_min : scalar or array_like or None
            Minimum value. If None, clipping is not performed on lower 
            interval edge. Not more than one of a_min and a_max may be None.

        a_max : scalar or array_like or None
            Maximum value. If None, clipping is not performed on upper 
            interval edge. Not more than one of a_min and a_max may be None. 
            If a_min or a_max are array_like, then the three arrays will be 
            broadcasted to match their shapes.

        out : ndarray, optional
            The results will be placed in this array. It may be the input 
            array for in-place clipping. out must be of the right shape to 
            hold the output. Its type is preserved.

    Returns

        clipped_array : ndarray
            An array with the elements of a, but where values &lt; a_min are 
            replaced with a_min, and those &gt; a_max with a_max.</pre> 
</div>
</div>
<a id="a73ae11a06791802ec2ca3a5059f2d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ae11a06791802ec2ca3a5059f2d275">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.compress </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return selected slices of an array along given axis.

    When working along a given axis, a slice along that axis is returned in output for each index where condition evaluates to True. When working on a 1-D array, compress is equivalent to extract.

    Parameters

        condition : 1-D array of bools
            Array that selects which entries to return. If len(condition) is less than the size of a along the given axis, then output is truncated to the length of the condition array.

        axis : int, optional
            Axis along which to take slices. If None (default), work on the flattened array.
    
        out : ndarray, optional
            Output array. Its type is preserved and it must be of the right shape to hold the output.

    Returns

        compressed_array : ndarray
            A copy of a without the slices along axis for which condition is false.
</pre> 
</div>
</div>
<a id="adc80e38b1c33dcf79976085be5a1acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc80e38b1c33dcf79976085be5a1acbf">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a copy of the array.
    
    Parameters:
        subok : bool, optional
            If True, then sub-classes will be passed-through, otherwise 
            the returned array will be forced to be a base-class array 
            (defaults to False).</pre> 
</div>
</div>
<a id="a8957f8dfc403736bfcba13aba437db7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8957f8dfc403736bfcba13aba437db7e">&#9670;&nbsp;</a></span>cumprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.cumprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the cumulative product of elements along a given axis.

    Parameters

        axis : int, optional
            Axis along which the cumulative product is computed. 
            By default the input is flattened.

        dtype : dtype, optional
            Type of the returned array, as well as of the accumulator 
            in which the elements are multiplied. If dtype is not 
            specified, it defaults to the dtype of a, unless a has an 
            integer dtype with a precision less than that of the 
            default platform integer. In that case, the default 
            platform integer is used instead.

        out : ndarray, optional
            Alternative output array in which to place the result. It 
            must have the same shape and buffer length as the expected 
            output but the type of the resulting values will be cast 
            if necessary.

    Returns

        cumprod : ndarray

            A new array holding the result is returned unless out is 
            specified, in which case a reference to out is returned.</pre> 
</div>
</div>
<a id="a1aed0d0ea9c4183c57277aad20623571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aed0d0ea9c4183c57277aad20623571">&#9670;&nbsp;</a></span>cumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.cumsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the cumulative sum of the elements along a given axis.

    Parameters

        axis : int, optional
            Axis along which the cumulative sum is computed. The default (None) 
            is to compute the cumsum over the flattened array.
        
        dtype : dtype, optional
            Type of the returned array and of the accumulator in which the 
            elements are summed. If dtype is not specified, it defaults to 
            the dtype of a, unless a has an integer dtype with a precision 
            less than that of the default platform integer. In that case, 
            the default platform integer is used.
        
        out : ndarray, optional
            Alternative output array in which to place the result. It must 
            have the same shape and buffer length as the expected output 
            but the type will be cast if necessary. See ufuncs-output-type 
            for more details.

    Returns

        cumsum_along_axis : ndarray.
            A new array holding the result is returned unless out is specified, 
            in which case a reference to out is returned. The result has the 
            same size as a, and the same shape as a if axis is not None or a is 
            a 1-d array.</pre> 
</div>
</div>
<a id="a97fa63a73d7b830c0c544f83a41b569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fa63a73d7b830c0c544f83a41b569c">&#9670;&nbsp;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.diagonal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return specified diagonals.
    If `a` is 2-D, returns the diagonal of `a` with the given offset,
    i.e., the collection of elements of the form ``a[i, i+offset]``.  If
    `a` has more than two dimensions, then the axes specified by `axis1`
    and `axis2` are used to determine the 2-D sub-array whose diagonal is
    returned.  The shape of the resulting array can be determined by
    removing `axis1` and `axis2` and appending an index to the right equal
    to the size of the resulting diagonals.

    Parameters
    ----------
        offset : int, optional
            Offset of the diagonal from the main diagonal.  Can be positive or
            negative.  Defaults to main diagonal (0).
        
        axis1 : int, optional
            Axis to be used as the first axis of the 2-D sub-arrays from which
            the diagonals should be taken.  Defaults to first axis (0).
        
        axis2 : int, optional
            Axis to be used as the second axis of the 2-D sub-arrays from
            which the diagonals should be taken. Defaults to second axis (1).

    Returns
    -------
        array_of_diagonals : ndarray
            If `a` is 2-D, then a 1-D array containing the diagonal and of the
            same type as `a` is returned unless `a` is a `matrix`, in which case
            a 1-D array rather than a (2-D) `matrix` is returned in order to
            maintain backward compatibility.
            If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`
            are removed, and a new axis inserted at the end corresponding to the
            diagonal.
    Raises
    ------
        ValueError
            If the dimension of `a` is less than 2.
</pre> 
</div>
</div>
<a id="a267f51491ed947496d2b7e2efbf99a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f51491ed947496d2b7e2efbf99a76">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.dot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Dot product of two arrays. Specifically,

        If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation).

        If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred.

        If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred.

        If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b.

        If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b:

        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

    Parameters

        b : array_like
            Second argument.

        out : ndarray, optional
            Output argument. This must have the exact kind that would be 
            returned if it was not used. In particular, it must have the 
            right type, must be C-contiguous, and its dtype must be the 
            dtype that would be returned for dot(a,b). This is a 
            performance feature. Therefore, if these conditions are not 
            met, an exception is raised, instead of attempting to be 
            flexible.

    Returns

        outputndarray

            Returns the dot product of a and b. If a and b are both scalars 
            or both 1-D arrays then a scalar is returned; otherwise an array 
            is returned. If out is given, then it is returned.

    Raises

        ValueError
            If the last dimension of a is not the same size as the 
            second-to-last dimension of b.</pre> 
</div>
</div>
<a id="a63ae58d6c7caa72ff92e07c077cb6ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ae58d6c7caa72ff92e07c077cb6ccb">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.dump </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Dump a pickle of the array to the specified file. The array 
    can be read back with pickle.load or numpy.load.

    Parameters

        file : str or Path
            A string naming the dump file.</pre> 
</div>
</div>
<a id="a98c4369edf088a69c66e80c9190ad85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c4369edf088a69c66e80c9190ad85a">&#9670;&nbsp;</a></span>dumps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.dumps </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Returns the pickle of the array as a string. pickle.loads or 
    numpy.loads will convert the string back to an array.

    Parameters: None
</pre> 
</div>
</div>
<a id="a8f90411a625588831b05a3c485374be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f90411a625588831b05a3c485374be1">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Fill the array with a scalar value.

    Parameters

       value : scalar
           All elements of a will be assigned this value.
</pre> 
</div>
</div>
<a id="a263850a9c6f87e0b97cc4939909add63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263850a9c6f87e0b97cc4939909add63">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.flatten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a copy of the array collapsed into one dimension.

    Parameters

        order : not supported

    Returns

        y : ndarray
            A copy of the input array, flattened to one dimension.</pre> 
</div>
</div>
<a id="a2c2412e5536ada63f4e15ea33fa6160f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2412e5536ada63f4e15ea33fa6160f">&#9670;&nbsp;</a></span>item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.item </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Copy an element of an array to a standard Python scalar and return it.

    Parameters
    
        *args : Arguments (variable number and type)
            none: in this case, the method only works for arrays with one 
            element (a.size == 1), which element is copied into a standard 
            Python scalar object and returned.
    
            int_type: this argument is interpreted as a flat index into 
            the array, specifying which element to copy and return.
    
            tuple of int_types: functions as does a single int_type 
            argument, except that the argument is interpreted as an 
            nd-index into the array.
    
    Returns
    
        z : Standard Python scalar object
            A copy of the specified element of the array as a suitable 
            Python scalar.</pre> 
</div>
</div>
<a id="aea5a7a1d0c87f0c1412790189d198cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5a7a1d0c87f0c1412790189d198cbb">&#9670;&nbsp;</a></span>itemset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.itemset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Insert scalar into an array (scalar is cast to array's dtype, if possible)

    There must be at least 1 argument, and define the last argument as item. 
    Then, a.itemset(*args) is equivalent to but faster than a[args] = item. 
    The item should be a scalar value and args must select a single item in 
    the array a.

    Parameters

        *args : Arguments
            If one argument: a scalar, only used in case a is of size 1. 
            If two arguments: the last argument is the value to be set and 
            must be a scalar, the first argument specifies a single array 
            element location. It is either an int or a tuple.

    Notes

        Compared to indexing syntax, itemset provides some speed increase 
        for placing a scalar into a particular location in an ndarray, if 
        you must do this. However, generally this is discouraged: among 
        other problems, it complicates the appearance of the code. Also, 
        when using itemset (and item) inside a loop, be sure to assign the 
        methods to a local variable to avoid the attribute look-up at each 
        loop iteration.
</pre> 
</div>
</div>
<a id="a10602777d2081f01c8013dba3494ae3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10602777d2081f01c8013dba3494ae3e">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the maximum along a given axis.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which to operate. 
            By default, flattened input is used.

            If this is a tuple of ints, the maximum is selected over multiple axes, 
            instead of a single axis or all the axes as before.

        out : ndarray, optional
            Alternative output array in which to place the result. Must be of the 
            same shape and buffer length as the expected output. See ufuncs-output-type 
            for more details.

        keepdims : not supported
        
        initial : scalar, optional
            The minimum value of an output element. Must be present to allow computation 
            on empty slice. See reduce for details.

        where : not supported

    Returns

        amax : ndarray or scalar
            Maximum of a. If axis is None, the result is a scalar value. If axis is given, 
            the result is an array of dimension a.ndim - 1.</pre> 
</div>
</div>
<a id="a5d1b6caaa3f08a49fff4d76c71713d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1b6caaa3f08a49fff4d76c71713d29">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Compute the arithmetic mean along the specified axis.

    Returns the average of the array elements. The average is taken over 
    the flattened array by default, otherwise over the specified axis. 
    float64 intermediate and return values are used for integer inputs.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which the means are computed. The default 
            is to compute the mean of the flattened array.

            If this is a tuple of ints, a mean is performed over multiple 
            axes, instead of a single axis or all the axes as before.
            
        dtype : data-type, optional
            Type to use in computing the mean. For integer inputs, the 
            default is float64; for floating point inputs, it is the same 
            as the input dtype.

        out : ndarray, optional
            Alternate output array in which to place the result. The 
            default is None; if provided, it must have the same shape as 
            the expected output, but the type will be cast if necessary. \
            
        keepdims : not supported

    Returns

        m : ndarray, see dtype parameter above
            If out=None, returns a new array containing the mean values, 
            otherwise a reference to the output array is returned.</pre> 
</div>
</div>
<a id="a76a2d7c2c937a06713f3cf233f4c2626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a2d7c2c937a06713f3cf233f4c2626">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the minimum along a given axis. 
    
    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which to operate. By default, flattened input is used.
            If this is a tuple of ints, the minimum is selected over multiple axes, 
            instead of a single axis or all the axes as before.

        out : ndarray, optional
            Alternative output array in which to place the result. Must be of the same 
            shape and buffer length as the expected output. See ufuncs-output-type for 
            more details.
        
        keepdims : not supported

        initial : scalar, optional
            The maximum value of an output element. Must be present to allow computation 
            on empty slice. See reduce for details.

        where : not supported

    Returns

        amin : ndarray or scalar
            Minimum of a. If axis is None, the result is a scalar value. If axis is given, 
            the result is an array of dimension a.ndim - 1.</pre> 
</div>
</div>
<a id="a95dd9026b7cdaa489ab3ac701b7d1162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd9026b7cdaa489ab3ac701b7d1162">&#9670;&nbsp;</a></span>moveaxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.moveaxis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Move axes of an array to new positions.

    Other axes remain in their original order.

    Parameters

        source : int or sequence of int
            Original positions of the axes to move. These must be unique.

        destination : int or sequence of int
            Destination positions for each of the original axes. These must also be unique.

    Returns

        result : np.ndarray
            Array with moved axes. This array is a view of the input array.</pre> 
</div>
</div>
<a id="a67c153eb3dbb44fa7220ef566e08b622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c153eb3dbb44fa7220ef566e08b622">&#9670;&nbsp;</a></span>nonzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.nonzero </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the indices of the elements that are non-zero.

    Returns a tuple of arrays, one for each dimension of a, containing the 
    indices of the non-zero elements in that dimension.
    
    Parameters
    
        None

    Returns

        tuple_of_arrays : tuple
            Indices of elements that are non-zero.</pre> 
</div>
</div>
<a id="a46963e32fc541e14bdb37b9a557cfe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46963e32fc541e14bdb37b9a557cfe5a">&#9670;&nbsp;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.prod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the product of array elements over a given axis.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which a product is performed. The default, axis=None, 
            will calculate the product of all the elements in the input array. 
            If axis is negative it counts from the last to the first axis.

            If axis is a tuple of ints, a product is performed on all of the axes 
            specified in the tuple instead of a single axis or all the axes as before.
            
        dtype : dtype, optional
            The type of the returned array, as well as of the accumulator in which 
            the elements are multiplied. The dtype of a is used by default unless a 
            has an integer dtype of less precision than the default platform integer. 
            In that case, if a is signed then the platform integer is used while if 
            a is unsigned then an unsigned integer of the same precision as the 
            platform integer is used.
            
        out : ndarray, optional
            Alternative output array in which to place the result. It must have the 
            same shape as the expected output, but the type of the output values 
            will be cast if necessary.
            
        keepdims : not supported

        initial : scalar, optional
            The starting value for this product. 

        where : not supported

    Returns

        product_along_axis : ndarray, see dtype parameter above.
            An array shaped as a but with the specified axis removed. Returns a 
            reference to out if specified.</pre> 
</div>
</div>
<a id="a29ea8d601f7e3747ee9d6a73877e0580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ea8d601f7e3747ee9d6a73877e0580">&#9670;&nbsp;</a></span>ptp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.ptp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Range of values (maximum - minimum) along an axis.

    The name of the function comes from the acronym for 'peak to peak'.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis along which to find the peaks. By default, flatten the array. 
            axis may be negative, in which case it counts from the last to the 
            first axis.

            If this is a tuple of ints, a reduction is performed on multiple 
            axes, instead of a single axis or all the axes as before.
            
        out : array_like
            Alternative output array in which to place the result. It must 
            have the same shape and buffer length as the expected output, but 
            the type of the output values will be cast if necessary.
            
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left in the 
            result as dimensions with size one. With this option, the result 
            will broadcast correctly against the input array.

            If the default value is passed, then keepdims will not be passed 
            through to the ptp method of sub-classes of ndarray, however any 
            non-default value will be. If the sub-class' method does not 
            implement keepdims any exceptions will be raised.

    Returns

        ptp : ndarray
            A new array holding the result, unless out was specified, in which 
            case a reference to out is returned.</pre> 
</div>
</div>
<a id="ac324583ee08905f693164ad5003aeb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac324583ee08905f693164ad5003aeb2c">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.put </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'raise'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Replaces specified elements of an array with given values.

    The indexing works on the flattened target array. put is roughly equivalent to:

    a.flat[ind] = v

    Parameters

        i : ndarray_like
            Target indices, interpreted as integers.

        v : array_like
            Values to place in a at target indices. If v is shorter than ind it will 
            be repeated as necessary.

        mode{'raise', 'wrap', 'clip'}, optional

            Specifies how out-of-bounds indices will behave.

                'raise' - raise an error (default)

                'wrap' - wrap around

                'clip' - clip to the range

            'clip' mode means that all indices that are too large are replaced by the 
            index that addresses the last element along that axis. Note that this 
            disables indexing with negative numbers. In 'raise' mode, if an exception 
            occurs the target array may still be modified.</pre> 
</div>
</div>
<a id="af6b0b8c63f9c89c45c3fe5881ac9655c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b0b8c63f9c89c45c3fe5881ac9655c">&#9670;&nbsp;</a></span>ravel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.ravel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a contiguous flattened array.

    A 1-D array, containing the elements of the input, is returned. 
    A copy is made only if needed.

    Parameters

        order : not supported

    Returns

        y : array_like
            y is an array of the same subtype as a, with shape (a.size,). </pre> 
</div>
</div>
<a id="a699d029bcaee37d7f6d9aaf2938b0ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699d029bcaee37d7f6d9aaf2938b0ff9">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.repeat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Repeat elements of an array.

    Parameters

        repeats : int or array of ints
            The number of repetitions for each element. repeats is broadcasted to 
            fit the shape of the given axis.

        axis : int, optional
            The axis along which to repeat values. By default, use the flattened 
            input array, and return a flat output array.

    Returns

        repeated_array : ndarray
            Output array which has the same shape as a, except along the given axis.</pre> 
</div>
</div>
<a id="a58ec6700a24a40b5e19d5c8aa3903135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ec6700a24a40b5e19d5c8aa3903135">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.reshape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Create a copy of the array with a new shape.

    Parameters

        newshape : int or tuple of ints
            The new shape should be compatible with the original shape. 
            If an integer, then the result will be a 1-D array of that length. 
            One shape dimension can be -1. In this case, the value is inferred 
            from the length of the array and remaining dimensions.

        order : not supported

    Returns
        reshaped_array : ndarray
            This will be a new copy of the array. </pre> 
</div>
</div>
<a id="a5aee52b0a73c9dccce97f82b011d3cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aee52b0a73c9dccce97f82b011d3cd8">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.resize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a new array with the specified shape.

    If the new array is larger than the original array, then the new array is 
    filled with repeated copies of a. Note that this behavior is different 
    from a.resize(new_shape) which fills with zeros instead of repeated copies 
    of a.

    Parameters

        new_shape : int or tuple of int
            Shape of resized array.

    Returns

        reshaped_array : ndarray
            The new array is formed from the data in the old array, repeated 
            if necessary to fill out the required number of elements. The data 
            are repeated in the order that they are stored in memory.</pre> 
</div>
</div>
<a id="a9df22bf1f3cffd1b3ab3f9923b9cc508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df22bf1f3cffd1b3ab3f9923b9cc508">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.round </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Evenly round to the given number of decimals.

    Parameters

        decimals : int, optional
            Number of decimal places to round to (default: 0). If decimals is negative, 
            it specifies the number of positions to the left of the decimal point.
        
        out : ndarray, optional
            Alternative output array in which to place the result. It must have the 
            same shape as the expected output, but the type of the output values will 
            be cast if necessary. 

    Returns

        rounded_array : ndarray
            An array of the same type as a, containing the rounded values. Unless 
            out was specified, a new array is created. A reference to the result is 
            returned.

            The real and imaginary parts of complex numbers are rounded separately. 
            The result of rounding a float is a float.</pre> 
</div>
</div>
<a id="aec315367ee238644b4c012b85a0694de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec315367ee238644b4c012b85a0694de">&#9670;&nbsp;</a></span>searchsorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.searchsorted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>side</em> = <code>'left'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sorter</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Find indices where elements should be inserted to maintain order.

    Find the indices into a sorted array a such that, if the corresponding 
    elements in v were inserted before the indices, the order of a would 
    be preserved.

    Assuming that a is sorted:

        side    returned index i satisfies
        left    a[i-1] &lt; v &lt;= a[i]
        right   a[i-1] &lt;= v &lt; a[i]

    Parameters

        v : array_like
            Values to insert into a.

        side : {'left', 'right'}, optional
            If 'left', the index of the first suitable location found is 
            given. If 'right', return the last such index. If there is no 
            suitable index, return either 0 or N (where N is the length 
            of a).
            
        sorter : not supported

    Returns

        indices : array of ints
            Array of insertion points with the same shape as v.</pre> 
</div>
</div>
<a id="a1320d6622923998bb2c1a0ddc25fd390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1320d6622923998bb2c1a0ddc25fd390">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return a sorted copy of an array.

    Parameters

        axis : int or None, optional
            Axis along which to sort. If None, the array is flattened before 
            sorting. The default is -1, which sorts along the last axis.
            
        kind : not supported

        order {'asc', 'desc'}: str or list of str, optional
            Ascending or descending

    Returns

        sorted_array : ndarray
            Array of the same type and shape as a.</pre> 
</div>
</div>
<a id="aff6ff18f4e3ea414cdab5d76bf47448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6ff18f4e3ea414cdab5d76bf47448c">&#9670;&nbsp;</a></span>squeeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.squeeze </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Remove single-dimensional entries from the shape of an array. Return 
    an array with the same storage.

    Parameters

        axis : None or int or tuple of ints, optional
            Selects a subset of the single-dimensional entries in the shape. 
            If an axis is selected with shape entry greater than one, 
            an error is raised.

    Returns

        squeezed : ndarray
            The input array, but with all or a subset of the dimensions of 
            length 1 removed. This is always a itself or a view into a. 
            Note that if all axes are squeezed, the result is a 0d array and 
            not a scalar.

    Raises

        ValueError
            If axis is not None, and an axis being squeezed is not of length 1</pre> 
</div>
</div>
<a id="a30d36ed3269a89b2aa72d3bf46de21c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d36ed3269a89b2aa72d3bf46de21c1">&#9670;&nbsp;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.std </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Compute the standard deviation along the specified axis.

    Returns the standard deviation, a measure of the spread of a distribution, 
    of the array elements. The standard deviation is computed for the flattened 
    array by default, otherwise over the specified axis.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which the standard deviation is computed. The 
            default is to compute the standard deviation of the flattened array.

            If this is a tuple of ints, a standard deviation is performed over 
            multiple axes, instead of a single axis or all the axes as before.
            
        dtype : dtype, optional
            Type to use in computing the standard deviation. For arrays of 
            integer type the default is float64, for arrays of float types 
            it is the same as the array type.

        out : ndarray, optional
            Alternative output array in which to place the result. It must 
            have the same shape as the expected output but the type (of the 
            calculated values) will be cast if necessary.

        ddof : int, optional
            Means Delta Degrees of Freedom. The divisor used in calculations 
            is N - ddof, where N represents the number of elements. 
            By default ddof is zero.

        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left in 
            the result as dimensions with size one. With this option, the 
            result will broadcast correctly against the input array.

            If the default value is passed, then keepdims will not be passed 
            through to the std method of sub-classes of ndarray, however any 
            non-default value will be. If the sub-class' method does not 
            implement keepdims any exceptions will be raised.

    Returns

        standard_deviationndarray, see dtype parameter above.
            If out is None, return a new array containing the standard 
            deviation, otherwise return a reference to the output array.</pre> 
</div>
</div>
<a id="a7a9921ab0d5328000e510065627f4768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9921ab0d5328000e510065627f4768">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.sum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Sum of array elements over a given axis.

    Parameters

        axis : None or int or tuple of ints, optional
            Axis or axes along which a sum is performed. The default, axis=None, 
            will sum all of the elements of the input array. If axis is negative 
            it counts from the last to the first axis.

            If axis is a tuple of ints, a sum is performed on all of the axes 
            specified in the tuple instead of a single axis or all the axes as 
            before.
            
        dtype : dtype, optional
            The type of the returned array and of the accumulator in which the 
            elements are summed. The dtype of a is used by default unless a has 
            an integer dtype of less precision than the default platform integer. 
            In that case, if a is signed then the platform integer is used while 
            if a is unsigned then an unsigned integer of the same precision as 
            the platform integer is used.
            
        out : ndarray, optional
            Alternative output array in which to place the result. It must have 
            the same shape as the expected output, but the type of the output 
            values will be cast if necessary.
            
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left in the 
            result as dimensions with size one. With this option, the result will 
            broadcast correctly against the input array.

            If the default value is passed, then keepdims will not be passed 
            through to the sum method of sub-classes of ndarray, however any 
            non-default value will be. If the sub-class' method does not implement 
            keepdims any exceptions will be raised.
            
        initial : scalar, optional
            Starting value for the sum. See reduce for details.

        where : not supported

    Returns

        sum_along_axis : ndarray
            An array with the same shape as a, with the specified axis removed. 
            If a is a 0-d array, or if axis is None, a scalar is returned. If an 
            output array is specified, a reference to out is returned.</pre> 
</div>
</div>
<a id="a1acfeed7c23a8b1e3964e300726bb25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acfeed7c23a8b1e3964e300726bb25b">&#9670;&nbsp;</a></span>swapaxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.swapaxes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Interchange two axes of an array.

    Parameters

        axis1 : int
            First axis.
        
        axis2 : int
            Second axis.

    Returns

        a_swapped : ndarray
            a veiw of the original array is returned</pre> 
</div>
</div>
<a id="abdaed6e6e798a20864538ec2f8d3dcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaed6e6e798a20864538ec2f8d3dcc8">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Take elements from an array along an axis.

    When axis is not None, this function does the same thing as "fancy" indexing 
    (indexing arrays using arrays); however, it can be easier to use if you need 
    elements along a given axis. A call such as np.take(arr, indices, axis=3) is 
    equivalent to arr[:,:,:,indices,...].

    Explained without fancy indexing, this is equivalent to the following use of 
    ndindex, which sets each of ii, jj, and kk to a tuple of indices:

        Ni, Nk = a.shape[:axis], a.shape[axis+1:]
        Nj = indices.shape
        for ii in ndindex(Ni):
            for jj in ndindex(Nj):
                for kk in ndindex(Nk):
                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]

    Parameters

        indices : array_like (Nj ...)
            The indices of the values to extract.

            Also allow scalars for indices.

        axis : int, optional
            The axis over which to select values. By default, the flattened input 
            array is used.
            
        out : ndarray, optional (Ni ..., Nj ..., Nk ...)
            If provided, the result will be placed in this array. It should be of 
            the appropriate shape and dtype. 
            
        mode : not supported

    Returns

        out : ndarray (Ni ..., Nj ..., Nk ...)
            The returned array has the same type as a.</pre> 
</div>
</div>
<a id="a1b1459af74bd1e5ff62773a95e5dae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1459af74bd1e5ff62773a95e5dae02">&#9670;&nbsp;</a></span>tolist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.tolist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the array as an a.ndim-levels deep nested list of Python scalars.

    Return a copy of the array data as a (nested) Python list. Data items are 
    converted to the nearest compatible builtin Python type, via the item 
    function.
    
    If a.ndim is 0, then since the depth of the nested list is 0, it will not 
    be a list at all, but a simple Python scalar.
    
    Parameters
    
        none
    
    Returns
    
        y : object, or list of object, or list of list of object, or 
    
            The possibly nested list of array elements.</pre> 
</div>
</div>
<a id="ac2350c9a650d043a40b2e170afe59652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2350c9a650d043a40b2e170afe59652">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.trace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Return the sum along diagonals of the array.

    If a is 2-D, the sum along its diagonal with the given offset is returned, 
    i.e., the sum of elements a[i,i+offset] for all i.

    If a has more than two dimensions, then the axes specified by axis1 and axis2 
    are used to determine the 2-D sub-arrays whose traces are returned. The shape 
    of the resulting array is the same as that of a with axis1 and axis2 removed.

    Parameters

        offset : int, optional
            Offset of the diagonal from the main diagonal. Can be both positive 
            and negative. Defaults to 0.
            
        axis1, axis2 : int, optional
            Axes to be used as the first and second axis of the 2-D sub-arrays 
            from which the diagonals should be taken. Defaults are the first two 
            axes of a.
            
        dtype : dtype, optional
            Determines the data-type of the returned array and of the accumulator 
            where the elements are summed. If dtype has the value None and a is 
            of integer type of precision less than the default integer precision, 
            then the default integer precision is used. Otherwise, the precision 
            is the same as that of a.
            
        out : ndarray, optional
            Array into which the output is placed. Its type is preserved and it 
            must be of the right shape to hold the output.

    Returns

        sum_along_diagonals : ndarray
            If a is 2-D, the sum along the diagonal is returned. If a has larger 
            dimensions, then an array of sums along diagonals is returned.</pre> 
</div>
</div>
<a id="ade2e7487ccfe87f2e8dff9e79902e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2e7487ccfe87f2e8dff9e79902e27a">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.transpose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Reverse or permute the axes of an array; returns the modified array.

    For an array a with two axes, transpose(a) gives the matrix transpose.

    Parameters

        axes : tuple or list of ints, optional
            If specified, it must be a tuple or list which contains a 
            permutation of [0,1,..,N-1] where N is the number of axes of a. 
            The i'th axis of the returned array will correspond to the axis 
            numbered axes[i] of the input. If not specified, defaults to 
            range(a.ndim)[::-1], which reverses the order of the axes.

    Returns

        p : ndarray
            a with its axes permuted. A view is returned whenever possible.</pre> 
</div>
</div>
<a id="a10dd7f02740a19bc157ea2408e7f7a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dd7f02740a19bc157ea2408e7f7a6e">&#9670;&nbsp;</a></span>tril()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.tril </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Lower triangle of an array.

    Return a copy of an array with elements above the k-th diagonal zeroed.

    Parameters

        k : int, optional
            Diagonal above which to zero elements. k = 0 (the default) is the 
            main diagonal, k &lt; 0 is below it and k &gt; 0 is above.

    Returns

        tril : ndarray, shape (M, N)
            Lower triangle of m, of same shape and data-type as m.</pre> 
</div>
</div>
<a id="aae42fa1b841700c3f1089b64f0804468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae42fa1b841700c3f1089b64f0804468">&#9670;&nbsp;</a></span>triu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Upper triangle of an array.

    Return a copy of a matrix with the elements below the k-th diagonal zeroed.

    Please refer to the documentation for tril for further details.</pre> 
</div>
</div>
<a id="ad98d3b9f0c855f2c479293317c89593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98d3b9f0c855f2c479293317c89593d">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.nparray.ndarray.var </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"> Compute the variance along the specified axis.

    Returns the variance of the array elements, a measure of the spread of 
    a distribution. The variance is computed for the flattened array by 
    default, otherwise over the specified axis.

    Parameters

        axis : None or int or tuple of ints, optional

            Axis or axes along which the variance is computed. The default 
            is to compute the variance of the flattened array.

            If this is a tuple of ints, a variance is performed over multiple 
            axes, instead of a single axis or all the axes as before.
            
        dtype : data-type, optional
            Type to use in computing the variance. For arrays of integer type 
            the default is float64; for arrays of float types it is the same 
            as the array type.
            
        out : ndarray, optional
            Alternate output array in which to place the result. It must have 
            the same shape as the expected output, but the type is cast if 
            necessary.
            
        ddof : int, optional
            "Delta Degrees of Freedom": the divisor used in the calculation 
            is N - ddof, where N represents the number of elements. By default 
            ddof is zero.
        
        keepdims : not support

    Returns

        variance : ndarray, see dtype parameter above
            If out=None, returns a new array containing the variance; otherwise, 
            a reference to the output array is returned.</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>nparray.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
